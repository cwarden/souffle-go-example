package main

import (
	"fmt"
	"runtime"
	"strings"

	"github.com/cwarden/souffle-go-example/SwigInterface"
)

func runSouffle(times int, x, y int64) {
	var mem runtime.MemStats
	for i := 0; i < times; i++ {
		p := SwigInterface.NewInstance("example")
		if p.Swigcptr() == 0 {
			panic("Souffle program not found")
		}
		p.LoadAll(".")
		edges := p.GetRelation("edge")

		threads := p.GetNumThreads()
		fmt.Print("\033[H\033[2J")
		fmt.Printf("Theads: %d\n", threads)

		// Use all of the cores
		p.SetNumThreads(int64(runtime.NumCPU()))

		threads = p.GetNumThreads()
		fmt.Printf("Theads: %d\n", threads)

		edges.Purge()

		// Create one edge.  The rest will be generated by the rule in
		// example.dl.
		t := edges.NewTuple()
		t.PutInteger(x)
		t.PutInteger(y)
		t.Insert()
		// Free memory allocated by c++ memory allocator
		SwigInterface.DeleteSWIGSouffleTuple(t)

		p.Run()
		paths := p.GetRelation("path")

		arity := paths.GetArity()
		size := paths.Size()
		fmt.Printf("ARITY: %d\n", arity)
		fmt.Printf("TUPLES: %d\n", size)
		fmt.Printf("SIGNATURE: %s\n", paths.GetSignature())
		var i, j uint
		for i = 0; i < size; i++ {
			tuple := paths.Next()

			var elements []string
			for j = 0; j < arity; j++ {
				elements = append(elements, fmt.Sprintf("%d", tuple.GetInteger(j)))
			}
			SwigInterface.DeleteSWIGSouffleTuple(tuple)

			_ = fmt.Sprintf("<%s>\n", strings.Join(elements, ","))
		}
		SwigInterface.DeleteSWIGSouffleRelation(paths)
		runtime.ReadMemStats(&mem)
		// Verify that we're not leaking memory
		fmt.Printf("Alloc %d; Sys: %d\n", mem.Alloc, mem.Sys)
		SwigInterface.DeleteSWIGSouffleProgram(p)
	}
}

func main() {
	// Run once, generating lots of tuples
	runSouffle(1, 3, 4)
	// Run a bunch of times generating a few tuples
	runSouffle(100000, 299995, 299998)
}
